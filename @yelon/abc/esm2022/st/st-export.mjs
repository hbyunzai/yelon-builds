import { Injectable, inject } from '@angular/core';
import { XlsxService } from '@yelon/abc/xlsx';
import { deepGet } from '@yelon/util/other';
import * as i0 from "@angular/core";
export class STExport {
    constructor() {
        this.xlsxSrv = inject(XlsxService, { optional: true });
    }
    _stGet(item, col, index, colIndex) {
        const ret = { t: 's', v: '' };
        if (col.format) {
            ret.v = col.format(item, col, index);
        }
        else {
            const val = item._values ? item._values[colIndex].text : deepGet(item, col.index, '');
            ret.v = val;
            if (val != null) {
                switch (col.type) {
                    case 'currency':
                        ret.t = 'n';
                        break;
                    case 'date':
                        // Can't be a empty value, it will cause `#NULL!`
                        // See https://github.com/SheetJS/sheetjs/blob/master/docbits/52_datatype.md
                        if (`${val}`.length > 0) {
                            ret.t = 'd';
                            // Number Formats: https://github.com/SheetJS/sheetjs/blob/master/docbits/63_numfmt.md
                            ret.z = col.dateFormat;
                        }
                        break;
                    case 'yn':
                        const yn = col.yn;
                        ret.v = val === yn.truth ? yn.yes : yn.no;
                        break;
                }
            }
        }
        ret.v = ret.v ?? '';
        return ret;
    }
    genSheet(opt) {
        const sheets = {};
        const sheet = (sheets[opt.sheetname || 'Sheet1'] = {});
        const dataLen = opt.data.length;
        const columns = opt.columens;
        let validColCount = 0;
        let wpx = false;
        const invalidFn = (col) => col.exported === false || !col.index || !(!col.buttons || col.buttons.length === 0);
        for (const [idx, col] of columns.entries()) {
            if (invalidFn(col))
                continue;
            if (!wpx && col._width != null)
                wpx = true;
            ++validColCount;
            const columnName = this.xlsxSrv.numberToSchema(validColCount);
            sheet[`${columnName}1`] = {
                t: 's',
                v: typeof col.title === 'object' ? col.title.text : col.title
            };
            for (let dataIdx = 0; dataIdx < dataLen; dataIdx++) {
                sheet[`${columnName}${dataIdx + 2}`] = this._stGet(opt.data[dataIdx], col, dataIdx, idx);
            }
        }
        if (wpx) {
            // wpx: width in screen pixels https://github.com/SheetJS/sheetjs#column-properties
            sheet['!cols'] = columns.filter(col => !invalidFn(col)).map(col => ({ wpx: col._width }));
        }
        if (validColCount > 0 && dataLen > 0) {
            sheet['!ref'] = `A1:${this.xlsxSrv.numberToSchema(validColCount)}${dataLen + 1}`;
        }
        return sheets;
    }
    async export(opt) {
        if (this.xlsxSrv == null) {
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                console.warn(`XlsxService service not found`);
            }
            return Promise.reject();
        }
        const sheets = this.genSheet(opt);
        return this.xlsxSrv.export({
            sheets,
            filename: opt.filename,
            callback: opt.callback
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: STExport, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: STExport }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: STExport, decorators: [{
            type: Injectable
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3QtZXhwb3J0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvYWJjL3N0L3N0LWV4cG9ydC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVuRCxPQUFPLEVBQW9CLFdBQVcsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQzs7QUFPNUMsTUFBTSxPQUFPLFFBQVE7SUFEckI7UUFFbUIsWUFBTyxHQUFHLE1BQU0sQ0FBQyxXQUFXLEVBQUUsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztLQXNGcEU7SUFwRlMsTUFBTSxDQUFDLElBQWUsRUFBRSxHQUFhLEVBQUUsS0FBYSxFQUFFLFFBQWdCO1FBQzVFLE1BQU0sR0FBRyxHQUFpQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDO1FBRTVELElBQUksR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ2YsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDdkMsQ0FBQzthQUFNLENBQUM7WUFDTixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsS0FBaUIsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNsRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNaLElBQUksR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO2dCQUNoQixRQUFRLEdBQUcsQ0FBQyxJQUFJLEVBQUUs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Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgaW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFhsc3hFeHBvcnRSZXN1bHQsIFhsc3hTZXJ2aWNlIH0gZnJvbSAnQHllbG9uL2FiYy94bHN4JztcbmltcG9ydCB7IGRlZXBHZXQgfSBmcm9tICdAeWVsb24vdXRpbC9vdGhlcic7XG5pbXBvcnQgdHlwZSB7IE56U2FmZUFueSB9IGZyb20gJ25nLXpvcnJvLWFudGQvY29yZS90eXBlcyc7XG5cbmltcG9ydCB7IFNUQ29sdW1uLCBTVEV4cG9ydE9wdGlvbnMgfSBmcm9tICcuL3N0LmludGVyZmFjZXMnO1xuaW1wb3J0IHsgX1NUQ29sdW1uIH0gZnJvbSAnLi9zdC50eXBlcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTVEV4cG9ydCB7XG4gIHByaXZhdGUgcmVhZG9ubHkgeGxzeFNydiA9IGluamVjdChYbHN4U2VydmljZSwgeyBvcHRpb25hbDogdHJ1ZSB9KTtcblxuICBwcml2YXRlIF9zdEdldChpdGVtOiBOelNhZmVBbnksIGNvbDogU1RDb2x1bW4sIGluZGV4OiBudW1iZXIsIGNvbEluZGV4OiBudW1iZXIpOiBOelNhZmVBbnkge1xuICAgIGNvbnN0IHJldDogeyBba2V5OiBzdHJpbmddOiBOelNhZmVBbnkgfSA9IHsgdDogJ3MnLCB2OiAnJyB9O1xuXG4gICAgaWYgKGNvbC5mb3JtYXQpIHtcbiAgICAgIHJldC52ID0gY29sLmZvcm1hdChpdGVtLCBjb2wsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsID0gaXRlbS5fdmFsdWVzID8gaXRlbS5fdmFsdWVzW2NvbEluZGV4XS50ZXh0IDogZGVlcEdldChpdGVtLCBjb2wuaW5kZXggYXMgc3RyaW5nW10sICcnKTtcbiAgICAgIHJldC52ID0gdmFsO1xuICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAoY29sLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdjdXJyZW5jeSc6XG4gICAgICAgICAgICByZXQudCA9ICduJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgLy8gQ2FuJ3QgYmUgYSBlbXB0eSB2YWx1ZSwgaXQgd2lsbCBjYXVzZSBgI05VTEwhYFxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9TaGVldEpTL3NoZWV0anMvYmxvYi9tYXN0ZXIvZG9jYml0cy81Ml9kYXRhdHlwZS5tZFxuICAgICAgICAgICAgaWYgKGAke3ZhbH1gLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmV0LnQgPSAnZCc7XG4gICAgICAgICAgICAgIC8vIE51bWJlciBGb3JtYXRzOiBodHRwczovL2dpdGh1Yi5jb20vU2hlZXRKUy9zaGVldGpzL2Jsb2IvbWFzdGVyL2RvY2JpdHMvNjNfbnVtZm10Lm1kXG4gICAgICAgICAgICAgIHJldC56ID0gY29sLmRhdGVGb3JtYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd5bic6XG4gICAgICAgICAgICBjb25zdCB5biA9IGNvbC55biE7XG4gICAgICAgICAgICByZXQudiA9IHZhbCA9PT0geW4udHJ1dGggPyB5bi55ZXMgOiB5bi5ubztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0LnYgPSByZXQudiA/PyAnJztcblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBwcml2YXRlIGdlblNoZWV0KG9wdDogU1RFeHBvcnRPcHRpb25zKTogeyBbc2hlZXQ6IHN0cmluZ106IHVua25vd24gfSB7XG4gICAgY29uc3Qgc2hlZXRzOiB7IFtzaGVldDogc3RyaW5nXTogeyBba2V5OiBzdHJpbmddOiBOelNhZmVBbnkgfSB9ID0ge307XG4gICAgY29uc3Qgc2hlZXQ6IHsgW2tleTogc3RyaW5nXTogTnpTYWZlQW55IH0gPSAoc2hlZXRzW29wdC5zaGVldG5hbWUgfHwgJ1NoZWV0MSddID0ge30pO1xuICAgIGNvbnN0IGRhdGFMZW4gPSBvcHQuZGF0YSEubGVuZ3RoO1xuICAgIGNvbnN0IGNvbHVtbnMgPSBvcHQuY29sdW1lbnMhIGFzIF9TVENvbHVtbltdO1xuICAgIGxldCB2YWxpZENvbENvdW50ID0gMDtcbiAgICBsZXQgd3B4ID0gZmFsc2U7XG4gICAgY29uc3QgaW52YWxpZEZuID0gKGNvbDogX1NUQ29sdW1uKTogYm9vbGVhbiA9PlxuICAgICAgY29sLmV4cG9ydGVkID09PSBmYWxzZSB8fCAhY29sLmluZGV4IHx8ICEoIWNvbC5idXR0b25zIHx8IGNvbC5idXR0b25zLmxlbmd0aCA9PT0gMCk7XG4gICAgZm9yIChjb25zdCBbaWR4LCBjb2xdIG9mIGNvbHVtbnMuZW50cmllcygpKSB7XG4gICAgICBpZiAoaW52YWxpZEZuKGNvbCkpIGNvbnRpbnVlO1xuICAgICAgaWYgKCF3cHggJiYgY29sLl93aWR0aCAhPSBudWxsKSB3cHggPSB0cnVlO1xuICAgICAgKyt2YWxpZENvbENvdW50O1xuICAgICAgY29uc3QgY29sdW1uTmFtZSA9IHRoaXMueGxzeFNydiEubnVtYmVyVG9TY2hlbWEodmFsaWRDb2xDb3VudCk7XG4gICAgICBzaGVldFtgJHtjb2x1bW5OYW1lfTFgXSA9IHtcbiAgICAgICAgdDogJ3MnLFxuICAgICAgICB2OiB0eXBlb2YgY29sLnRpdGxlID09PSAnb2JqZWN0JyA/IGNvbC50aXRsZS50ZXh0IDogY29sLnRpdGxlXG4gICAgICB9O1xuICAgICAgZm9yIChsZXQgZGF0YUlkeCA9IDA7IGRhdGFJZHggPCBkYXRhTGVuOyBkYXRhSWR4KyspIHtcbiAgICAgICAgc2hlZXRbYCR7Y29sdW1uTmFtZX0ke2RhdGFJZHggKyAyfWBdID0gdGhpcy5fc3RHZXQob3B0LmRhdGEhW2RhdGFJZHhdLCBjb2wsIGRhdGFJZHgsIGlkeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh3cHgpIHtcbiAgICAgIC8vIHdweDogd2lkdGggaW4gc2NyZWVuIHBpeGVscyBodHRwczovL2dpdGh1Yi5jb20vU2hlZXRKUy9zaGVldGpzI2NvbHVtbi1wcm9wZXJ0aWVzXG4gICAgICBzaGVldFsnIWNvbHMnXSA9IGNvbHVtbnMuZmlsdGVyKGNvbCA9PiAhaW52YWxpZEZuKGNvbCkpLm1hcChjb2wgPT4gKHsgd3B4OiBjb2wuX3dpZHRoIH0pKTtcbiAgICB9XG5cbiAgICBpZiAodmFsaWRDb2xDb3VudCA+IDAgJiYgZGF0YUxlbiA+IDApIHtcbiAgICAgIHNoZWV0WychcmVmJ10gPSBgQTE6JHt0aGlzLnhsc3hTcnYhLm51bWJlclRvU2NoZW1hKHZhbGlkQ29sQ291bnQpfSR7ZGF0YUxlbiArIDF9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hlZXRzO1xuICB9XG5cbiAgYXN5bmMgZXhwb3J0KG9wdDogU1RFeHBvcnRPcHRpb25zKTogUHJvbWlzZTxYbHN4RXhwb3J0UmVzdWx0PiB7XG4gICAgaWYgKHRoaXMueGxzeFNydiA9PSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgWGxzeFNlcnZpY2Ugc2VydmljZSBub3QgZm91bmRgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHNoZWV0cyA9IHRoaXMuZ2VuU2hlZXQob3B0KTtcbiAgICByZXR1cm4gdGhpcy54bHN4U3J2LmV4cG9ydCh7XG4gICAgICBzaGVldHMsXG4gICAgICBmaWxlbmFtZTogb3B0LmZpbGVuYW1lLFxuICAgICAgY2FsbGJhY2s6IG9wdC5jYWxsYmFja1xuICAgIH0pO1xuICB9XG59XG4iXX0=